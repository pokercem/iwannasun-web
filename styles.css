"""Forecast fetch + cache.

Open-Meteo hourly data is cached in-memory (LRU + TTL) and optionally
interpolated to a 10-minute UTC index.
"""

from __future__ import annotations

import threading
import time
from collections import OrderedDict

import pandas as pd
import requests
from fastapi import HTTPException


# --- CONFIG ---

OPEN_METEO_URL = "https://api.open-meteo.com/v1/forecast"

FORECAST_CACHE_TTL_SEC = 60 * 60
FORECAST_CACHE_STALE_MAX_SEC = 6 * 60 * 60
FORECAST_CACHE_MAX_ITEMS = 800
INTERP_CACHE_MAX_ITEMS = 2000


# --- HTTP ---

_HTTP_LOCAL = threading.local()


def _http_get(url, params, timeout):
    s = getattr(_HTTP_LOCAL, "session", None)
    if s is None:
        s = requests.Session()
        adapter = requests.adapters.HTTPAdapter(pool_connections=20, pool_maxsize=20, max_retries=0)
        s.mount("https://", adapter)
        s.mount("http://", adapter)
        _HTTP_LOCAL.session = s
    return s.get(url, params=params, timeout=timeout)


# --- CACHE (LRU + TTL) ---

_forecast_lock = threading.Lock()
# key -> (ts_monotonic, df)
_forecast_cache: "OrderedDict[str, tuple[float, pd.DataFrame]]" = OrderedDict()

_interp_lock = threading.Lock()
# key -> (ts_monotonic, df_10min)
_interp_cache: "OrderedDict[str, tuple[float, pd.DataFrame]]" = OrderedDict()


def _now() -> float:
    return time.monotonic()


def _round2(x: float) -> float:
    return float(f"{float(x):.2f}")


def _forecast_cache_key(lat: float, lon: float, days: int) -> str:
    return f"fc:{_round2(lat)}:{_round2(lon)}:{int(days)}"


def _cache_peek(key: str):
    return _forecast_cache.get(key)


def _cache_touch(key: str):
    try:
        _forecast_cache.move_to_end(key)
    except KeyError:
        return


def _cache_set(key: str, df: pd.DataFrame):
    now = _now()
    with _forecast_lock:
        _forecast_cache[key] = (now, df)
        _cache_touch(key)

        while len(_forecast_cache) > FORECAST_CACHE_MAX_ITEMS:
            _forecast_cache.popitem(last=False)

        # Opportunistic TTL pruning from the front.
        cutoff = now - FORECAST_CACHE_STALE_MAX_SEC
        for _ in range(8):
            if not _forecast_cache:
                break
            k0, (ts0, _) = next(iter(_forecast_cache.items()))
            if ts0 >= cutoff:
                break
            _forecast_cache.pop(k0, None)


def _cache_get_fresh(key: str):
    now = _now()
    with _forecast_lock:
        item = _cache_peek(key)
        if not item:
            return None
        ts, df = item
        if now - ts > FORECAST_CACHE_TTL_SEC:
            _forecast_cache.pop(key, None)
            return None
        _cache_touch(key)
        return df


def _cache_get_stale_ok(key: str):
    now = _now()
    with _forecast_lock:
        item = _cache_peek(key)
        if not item:
            return None
        ts, df = item
        if now - ts > FORECAST_CACHE_STALE_MAX_SEC:
            return None
        _cache_touch(key)
        return df


# --- FETCH ---


def _fetch_hourly_df(lat: float, lon: float, days: int) -> pd.DataFrame:
    ck = _forecast_cache_key(lat, lon, days)
    cached = _cache_get_fresh(ck)
    if cached is not None:
        return cached.copy(deep=False)

    params = {
        "latitude": lat,
        "longitude": lon,
        "hourly": "cloud_cover_low,cloud_cover_mid,cloud_cover_high,precipitation,direct_normal_irradiance",
        "timezone": "UTC",
        "forecast_days": int(days),
    }

    def _retry_after_seconds(resp: requests.Response) -> float | None:
        ra = resp.headers.get("Retry-After")
        if not ra:
            return None
        try:
            return float(ra)
        except Exception:
            return None

    last_err = None
    data = None

    for attempt in range(3):
        try:
            r = _http_get(OPEN_METEO_URL, params=params, timeout=(5, 20))

            if r.status_code == 429:
                stale = _cache_get_stale_ok(ck)
                if stale is not None:
                    return stale.copy(deep=False)

                wait_s = _retry_after_seconds(r)
                if wait_s is None:
                    wait_s = 0.6 * (2**attempt)
                time.sleep(max(0.0, min(float(wait_s), 2.5)))
                continue

            r.raise_for_status()
            data = r.json()
            break

        except (requests.RequestException, ValueError) as e:
            last_err = e
            time.sleep(0.4 * (2**attempt))

    if data is None:
        stale = _cache_get_stale_ok(ck)
        if stale is not None:
            return stale.copy(deep=False)

        if isinstance(last_err, ValueError):
            raise HTTPException(status_code=502, detail="Forecast provider returned invalid data")
        raise HTTPException(status_code=502, detail="Forecast provider temporarily unavailable")

    hourly = data.get("hourly") or {}
    h_times = hourly.get("time") or []
    if not h_times:
        raise HTTPException(status_code=502, detail="No hourly data from forecast provider")

    n = len(h_times)

    def _col(name: str):
        v = hourly.get(name)
        if v is None:
            v = [None] * n
        if len(v) < n:
            v = list(v) + [None] * (n - len(v))
        elif len(v) > n:
            v = list(v)[:n]
        return v

    df = (
        pd.DataFrame(
            {
                "time": pd.to_datetime(h_times, utc=True),
                "low": _col("cloud_cover_low"),
                "mid": _col("cloud_cover_mid"),
                "high": _col("cloud_cover_high"),
                "precip": _col("precipitation"),
                "dni": _col("direct_normal_irradiance"),
            }
        )
        .set_index("time")
        .sort_index()
    )

    for c in ["low", "mid", "high", "precip", "dni"]:
        df[c] = pd.to_numeric(df[c], errors="coerce")

    _cache_set(ck, df)
    return df


# --- INTERP ---


def _interp_to_10min(dfh: pd.DataFrame, idx_utc) -> pd.DataFrame:
    idx_utc = pd.DatetimeIndex(pd.to_datetime(idx_utc, utc=True))

    for c in ["low", "mid", "high", "precip", "dni"]:
        if c not in dfh.columns:
            dfh[c] = pd.NA

    union_idx = dfh.index.union(idx_utc)
    dft = dfh.reindex(union_idx).sort_index()
    dft = dft.interpolate(method="time", limit_area="inside")
    dft = dft.ffill(limit=6).bfill(limit=6)
    return dft.reindex(idx_utc)


# --- PUBLIC ---


def _interp_sig(idx_utc: pd.DatetimeIndex) -> str:
    if len(idx_utc) == 0:
        return "empty"
    return f"{int(idx_utc[0].value)}:{int(idx_utc[-1].value)}:{int(len(idx_utc))}"


def _interp_cache_get(key: str):
    with _interp_lock:
        item = _interp_cache.get(key)
        if not item:
            return None
        _interp_cache.move_to_end(key)
        return item[1]


def _interp_cache_set(key: str, df: pd.DataFrame):
    with _interp_lock:
        _interp_cache[key] = (_now(), df)
        _interp_cache.move_to_end(key)
        while len(_interp_cache) > INTERP_CACHE_MAX_ITEMS:
            _interp_cache.popitem(last=False)


def get_forecast_df(lat: float, lon: float, days: int, idx_utc=None) -> pd.DataFrame:
    dfh = _fetch_hourly_df(lat, lon, days)
    if idx_utc is None:
        return dfh

    idx_utc = pd.DatetimeIndex(pd.to_datetime(idx_utc, utc=True))

    ck = _forecast_cache_key(lat, lon, days)
    with _forecast_lock:
        item = _forecast_cache.get(ck)
        src_ts = item[0] if item else 0.0

    ik = f"it:{ck}:{src_ts:.3f}:{_interp_sig(idx_utc)}"
    cached = _interp_cache_get(ik)
    if cached is not None:
        return cached.copy(deep=False)

    dft = _interp_to_10min(dfh, idx_utc)
    _interp_cache_set(ik, dft)
    return dft

