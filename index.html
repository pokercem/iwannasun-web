<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iwannasun</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    h1 { margin: 0 0 8px 0; }
    .muted { color: #666; font-size: 14px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; align-items: center; }
    button, input, select { font-size: 16px; padding: 10px 12px; }
    button { cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; }
    .ok { color: #0a7; }
    .bad { color: #c22; }
    .timeline { max-height: 55vh; overflow: auto; }
    .item { display: flex; justify-content: space-between; gap: 10px; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
    .pill { padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 13px; white-space: nowrap; }
    canvas { width: 100%; height: 180px; display: block; }
    .small { font-size: 13px; }
  </style>
</head>
<body>
  <h1>iwannasun</h1>
  <div class="muted">Direct sun probability ‚Äî simple MVP</div>

  <div class="card">
    <div class="row">
      <button id="locBtn">Use my location</button>
      <button id="demoBtn">Demo (Amsterdam)</button>
    </div>

    <div class="row">
      <label class="muted">Sunny threshold (0‚Äì100)</label>
      <input id="threshold" type="number" min="0" max="100" value="70" style="width: 110px;">

      <label class="muted">Day</label>
      <select id="dayPick">
        <option value="0">Today</option>
        <option value="1">Tomorrow</option>
      </select>

      <button id="refreshBtn">Refresh</button>
    </div>

    <div class="muted">API:</div>
    <div class="mono" id="apiUrl"></div>
    <div class="muted">(If your API URL changes, edit <span class="mono">API_BASE</span> in this file.)</div>
  </div>

  <div class="card">
    <div id="status" class="muted">Waiting‚Ä¶</div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Right now</h3>
    <div id="decision" style="font-size:18px;">‚Äî</div>
    <div id="decisionSub" class="muted"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Next sunny window</h3>
    <div id="nextWindow" class="muted">‚Äî</div>
    <div id="expectedSun" class="muted small" style="margin-top:6px;"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Sun path (elevation)</h3>
    <div style="border:1px solid #eee; border-radius:10px; padding:10px;">
      <canvas id="sunCanvas" width="1000" height="220"></canvas>
      <div class="muted small" style="margin-top:8px;">
        Line shows sun elevation. Highlighted segments mean <b>sun_score ‚â• threshold</b>. Vertical line is <b>now</b>.
      </div>
      <div class="muted small" id="sunAxis"></div>
    </div>
  </div>

  <div class="card timeline">
    <h3 id="timelineTitle" style="margin:0 0 8px 0;">Today (daylight only)</h3>
    <div id="timeline"></div>
  </div>

<script>
  // ‚úÖ EDIT THIS if your backend URL changes:
  const API_BASE = "https://iwannasun.onrender.com";

  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const nextEl = $("nextWindow");
  const expectedEl = $("expectedSun");
  const timelineEl = $("timeline");
  const timelineTitleEl = $("timelineTitle");
  const decisionEl = $("decision");
  const decisionSubEl = $("decisionSub");
  const canvas = $("sunCanvas");
  const sunAxisEl = $("sunAxis");
  const ctx = canvas.getContext("2d");

  $("apiUrl").textContent = API_BASE;

  let lastLatLon = null;
  let lastData = null;

  function fmtTimeLocal(isoWithOffset) {
    const d = new Date(isoWithOffset);
    return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  function fmtDayTime(isoWithOffset) {
    const d = new Date(isoWithOffset);
    const day = d.toLocaleDateString([], { weekday: "short", month: "short", day: "2-digit" });
    const time = d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    return `${day} ${time}`;
  }

  function scoreLabel(score) {
    if (score >= 80) return "SUN";
    if (score >= 60) return "MIX";
    if (score >= 30) return "CLOUD";
    return "NO";
  }

  function pillForScore(score) {
    const label = scoreLabel(score);
    return `<span class="pill">${label} ${score}</span>`;
  }

  function nearestIndexByUtc(timeline) {
    const now = Date.now();
    let bestI = 0;
    let bestD = Infinity;
    for (let i = 0; i < timeline.length; i++) {
      const t = new Date(timeline[i].time_utc).getTime();
      const d = Math.abs(t - now);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  async function fetchDay(lat, lon) {
    const thr = Number($("threshold").value || 70);
    const url = `${API_BASE}/day?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&threshold=${encodeURIComponent(thr)}&days=2`;
    statusEl.textContent = "Loading‚Ä¶ (free server may take a bit to wake up)";
    const res = await fetch(url);
    if (!res.ok) throw new Error(`API error: ${res.status}`);
    return await res.json();
  }

  function drawSunPath(dayPoints, threshold) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!dayPoints.length) return;

    const W = canvas.width, H = canvas.height;
    const padL = 40, padR = 20, padT = 20, padB = 30;

    const elevs = dayPoints.map(p => p.elevation);
    const minE = Math.min(...elevs, 0);
    const maxE = Math.max(...elevs, 1);

    const t0 = new Date(dayPoints[0].time_utc).getTime();
    const t1 = new Date(dayPoints[dayPoints.length - 1].time_utc).getTime();

    const xForT = (t) => {
      const u = (t - t0) / (t1 - t0 || 1);
      return padL + u * (W - padL - padR);
    };
    const yForE = (e) => {
      const u = (e - minE) / (maxE - minE || 1);
      return (H - padB) - u * (H - padT - padB);
    };

    // baseline axis
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#eee";
    ctx.beginPath();
    ctx.moveTo(padL, H - padB);
    ctx.lineTo(W - padR, H - padB);
    ctx.stroke();

    // draw grey elevation curve
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#bbb";
    ctx.beginPath();
    for (let i = 0; i < dayPoints.length; i++) {
      const p = dayPoints[i];
      const t = new Date(p.time_utc).getTime();
      const x = xForT(t);
      const y = yForE(p.elevation);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    // highlight segments where score >= threshold (green)
    ctx.lineWidth = 3;
    ctx.strokeStyle = "#0a7";
    ctx.beginPath();
    let drawing = false;
    for (let i = 0; i < dayPoints.length; i++) {
      const p = dayPoints[i];
      const ok = p.sun_score >= threshold;
      const t = new Date(p.time_utc).getTime();
      const x = xForT(t);
      const y = yForE(p.elevation);

      if (ok) {
        if (!drawing) {
          ctx.moveTo(x, y);
          drawing = true;
        } else {
          ctx.lineTo(x, y);
        }
      } else {
        drawing = false;
        ctx.moveTo(x, y);
      }
    }
    ctx.stroke();

    // vertical "now" line if within range
    const now = Date.now();
    if (now >= t0 && now <= t1) {
      const xNow = xForT(now);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ddd";
      ctx.beginPath();
      ctx.moveTo(xNow, padT);
      ctx.lineTo(xNow, H - padB);
      ctx.stroke();
    }

    // labels (start/end)
    const startLabel = fmtTimeLocal(dayPoints[0].time_local);
    const endLabel = fmtTimeLocal(dayPoints[dayPoints.length - 1].time_local);
    sunAxisEl.textContent = `${startLabel}  ‚Äî  ${endLabel}`;
  }

  function render(data) {
    const thr = Number($("threshold").value || 70);
    const tl = data.timeline || [];

    const dayPick = Number($("dayPick")?.value || 0);

    // Daylight points for selected day (0=today, 1=tomorrow)
    const dayDaylight = tl.filter(p => p.day_index === dayPick && p.elevation > 0);

    // Status line
    statusEl.textContent = `Loaded. Daylight points: ${dayDaylight.length} (of ${tl.length}) ‚Ä¢ TZ: ${data.meta?.tz_name || "?"}`;

    // Decision (right now) - always uses "now", not the selected day
    const iNow = nearestIndexByUtc(tl);
    const pNow = tl[iNow];

    if (!pNow) {
      decisionEl.textContent = "‚Äî";
      decisionSubEl.textContent = "";
    } else if (pNow.elevation <= 0) {
      decisionEl.textContent = "üåô Night ‚Äî no direct sun";
      decisionSubEl.textContent = "Sun is below the horizon.";
    } else if (pNow.sun_score >= thr) {
      decisionEl.textContent = "‚òÄÔ∏è Go now ‚Äî direct sun likely";
      decisionSubEl.textContent = `Sun score ${pNow.sun_score} ‚Ä¢ confidence ${Math.round((pNow.confidence||0)*100)}%`;
    } else {
      decisionEl.textContent = "‚õÖ Not strong sun right now";
      decisionSubEl.textContent = `Sun score ${pNow.sun_score} ‚Ä¢ confidence ${Math.round((pNow.confidence||0)*100)}%`;
    }

    // Next window (can be tomorrow)
    const win = data.next_sunny_window;
    if (!win) {
      nextEl.innerHTML = `<span class="bad">No sunny window above threshold coming up.</span>`;
    } else {
      nextEl.innerHTML = `<span class="ok">${fmtDayTime(win.start)} ‚Üí ${fmtDayTime(win.end)}</span>`;
    }

    // Expected sun minutes
    const sm = data.sun_minutes || {};
    expectedEl.textContent = `Expected sun: next 1h ${sm.next_1h ?? 0} min ‚Ä¢ next 2h ${sm.next_2h ?? 0} min`;

    // Sun path chart (selected day daylight points)
    drawSunPath(dayDaylight, thr);

    // Timeline (selected day daylight only)
    timelineTitleEl.textContent = (dayPick === 0 ? "Today" : "Tomorrow") + " (daylight only)";
    const rows = dayDaylight.map(p => {
      const t = fmtTimeLocal(p.time_local);
      const conf = Math.round((p.confidence || 0) * 100);
      return `
        <div class="item">
          <div>
            <div><b>${t}</b> <span class="muted">elev ${p.elevation.toFixed(1)}¬∞</span></div>
            <div class="muted">conf ${conf}% ‚Ä¢ clouds L${p.cloud.low}% M${p.cloud.mid}% H${p.cloud.high}%</div>
          </div>
          <div>${pillForScore(p.sun_score)}</div>
        </div>
      `;
    }).join("");

    timelineEl.innerHTML = rows || `<div class="muted">No daylight points for this day.</div>`;
  }

  async function runWithLatLon(lat, lon) {
    lastLatLon = { lat, lon };
    try {
      const data = await fetchDay(lat, lon);
      lastData = data;
      render(data);
    } catch (e) {
      statusEl.innerHTML = `<span class="bad">${e.message}</span>`;
    }
  }

  $("demoBtn").addEventListener("click", () => runWithLatLon(52.37, 4.90));

  $("locBtn").addEventListener("click", () => {
    if (!navigator.geolocation) {
      statusEl.innerHTML = `<span class="bad">Geolocation not supported in this browser.</span>`;
      return;
    }
    statusEl.textContent = "Requesting location permission‚Ä¶";
    navigator.geolocation.getCurrentPosition(
      (pos) => runWithLatLon(pos.coords.latitude, pos.coords.longitude),
      (err) => statusEl.innerHTML = `<span class="bad">Location error: ${err.message}</span>`,
      { enableHighAccuracy: true, timeout: 15000 }
    );
  });

  $("refreshBtn").addEventListener("click", () => {
    if (!lastLatLon) {
      statusEl.textContent = "Pick Demo or Use my location first.";
      return;
    }
    runWithLatLon(lastLatLon.lat, lastLatLon.lon);
  });

  // Re-render (no refetch) when day changes
  $("dayPick").addEventListener("change", () => {
    if (lastData) render(lastData);
  });
</script>
</body>
</html>
