<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iwannasun</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    h1 { margin: 0 0 8px 0; }
    .muted { color: #666; font-size: 14px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; align-items: center; }
    button, input { font-size: 16px; padding: 10px 12px; }
    button { cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; }
    .ok { color: #0a7; }
    .bad { color: #c22; }
    .timeline { max-height: 45vh; overflow: auto; }
    .item { display: flex; justify-content: space-between; gap: 10px; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
    .pill { padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 13px; }
    canvas { width: 100%; height: 220px; display:block; border: 1px solid #eee; border-radius: 10px; }
  </style>
</head>
<body>
  <h1>iwannasun</h1>
  <div class="muted">Direct sun probability ‚Äî simple MVP</div>

  <div class="card">
    <div class="row">
      <button id="locBtn">Use my location</button>
      <button id="demoBtn">Demo (Amsterdam)</button>
    </div>

    <div class="row">
      <label class="muted">Sunny threshold (0‚Äì100)</label>
      <input id="threshold" type="number" min="0" max="100" value="70" style="width: 110px;">
      <button id="refreshBtn">Refresh</button>
    </div>

    <div class="muted">API:</div>
    <div class="mono" id="apiUrl">https://iwannasun.onrender.com</div>
    <div class="muted">(If your API URL changes, edit API_BASE in this file.)</div>
  </div>

  <div class="card">
    <div id="status" class="muted">Waiting‚Ä¶</div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Right now</h3>
    <div id="decision" style="font-size:18px;">‚Äî</div>
    <div id="decisionSub" class="muted"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Next sunny window</h3>
    <div id="nextWindow" class="muted">‚Äî</div>
    <div id="sunMinutes" class="muted" style="margin-top:6px;"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Sun path (elevation)</h3>
    <canvas id="sunChart"></canvas>
    <div class="muted" style="margin-top:8px;">
      Line shows sun elevation. Highlighted segments mean <b>sun_score ‚â• threshold</b>. Vertical line is <b>now</b>.
    </div>
  </div>

  <div class="card timeline">
    <h3 style="margin:0 0 8px 0;">Today (daylight only)</h3>
    <div id="timeline"></div>
  </div>

<script>
  const API_BASE = "https://iwannasun.onrender.com";

  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const nextEl = $("nextWindow");
  const sunMinutesEl = $("sunMinutes");
  const timelineEl = $("timeline");
  const decisionEl = $("decision");
  const decisionSubEl = $("decisionSub");
  const chart = $("sunChart");
  const ctx = chart.getContext("2d");

  let lastLatLon = null; // {lat, lon}

  function fmtTimeLocalFromUtcIso(isoUtc) {
    const d = new Date(isoUtc);
    return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  function scoreLabel(score) {
    if (score >= 80) return "SUN";
    if (score >= 60) return "MIX";
    if (score >= 30) return "CLOUD";
    return "NO";
  }

  function pillForScore(score) {
    const label = scoreLabel(score);
    return `<span class="pill">${label} ${score}</span>`;
  }

  function findNearestIndex(timeline) {
    const now = Date.now();
    let bestI = 0;
    let bestD = Infinity;
    for (let i = 0; i < timeline.length; i++) {
      const t = new Date(timeline[i].time_utc).getTime();
      const d = Math.abs(t - now);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  function findNextAbove(timeline, startIndex, threshold, maxMinutesAhead = 360) {
    const now = Date.now();
    const maxMs = maxMinutesAhead * 60 * 1000;
    for (let i = startIndex; i < timeline.length; i++) {
      const tMs = new Date(timeline[i].time_utc).getTime();
      if (tMs - now > maxMs) break;
      if (timeline[i].sun_score >= threshold && timeline[i].elevation > 0) return i;
    }
    return null;
  }

  async function fetchDay(lat, lon) {
    const thr = Number($("threshold").value || 70);
    const url = `${API_BASE}/day?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&threshold=${encodeURIComponent(thr)}`;
    $("apiUrl").textContent = API_BASE;
    statusEl.textContent = "Loading‚Ä¶ (free server may take a bit to wake up)";
    const res = await fetch(url);
    if (!res.ok) throw new Error(`API error: ${res.status}`);
    return await res.json();
  }

  function resizeCanvasToCSSPixels(canvas) {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
    return dpr;
  }

  function drawSunChart(daylight, threshold, nextWindow) {
    const dpr = resizeCanvasToCSSPixels(chart);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const w = chart.getBoundingClientRect().width;
    const h = chart.getBoundingClientRect().height;

    ctx.clearRect(0, 0, w, h);

    const padL = 36, padR = 10, padT = 12, padB = 24;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;

    if (!daylight.length) {
      ctx.fillText("No daylight points", 10, 20);
      return;
    }

    const times = daylight.map(p => new Date(p.time_utc).getTime());
    const elevs = daylight.map(p => p.elevation);

    const tMin = Math.min(...times);
    const tMax = Math.max(...times);
    const eMin = 0;
    const eMax = Math.max(...elevs, 1);

    const xOf = (tMs) => padL + ((tMs - tMin) / (tMax - tMin)) * plotW;
    const yOf = (e) => padT + (1 - ((e - eMin) / (eMax - eMin))) * plotH;

    // axes (light)
    ctx.globalAlpha = 1;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#eee";
    ctx.beginPath();
    ctx.moveTo(padL, padT);
    ctx.lineTo(padL, padT + plotH);
    ctx.lineTo(padL + plotW, padT + plotH);
    ctx.stroke();

    // next window shading
    if (nextWindow && nextWindow.start_utc && nextWindow.end_utc) {
      const a = new Date(nextWindow.start_utc).getTime();
      const b = new Date(nextWindow.end_utc).getTime();
      const x1 = xOf(Math.max(a, tMin));
      const x2 = xOf(Math.min(b, tMax));
      if (x2 > x1) {
        ctx.fillStyle = "rgba(0,160,120,0.10)";
        ctx.fillRect(x1, padT, x2 - x1, plotH);
      }
    }

    // draw line segments (highlight if sunny)
    for (let i = 0; i < daylight.length - 1; i++) {
      const p1 = daylight[i];
      const p2 = daylight[i + 1];

      const x1 = xOf(new Date(p1.time_utc).getTime());
      const y1 = yOf(p1.elevation);
      const x2 = xOf(new Date(p2.time_utc).getTime());
      const y2 = yOf(p2.elevation);

      const sunny = (p1.sun_score >= threshold) && (p2.sun_score >= threshold);

      ctx.strokeStyle = sunny ? "#0a7" : "#bbb";
      ctx.lineWidth = sunny ? 2.5 : 2;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // now marker
    const now = Date.now();
    if (now >= tMin && now <= tMax) {
      const xNow = xOf(now);
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(xNow, padT);
      ctx.lineTo(xNow, padT + plotH);
      ctx.stroke();
    }

    // labels (start/end time)
    ctx.fillStyle = "#666";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(fmtTimeLocalFromUtcIso(new Date(tMin).toISOString()), padL, padT + plotH + 18);
    const endLabel = fmtTimeLocalFromUtcIso(new Date(tMax).toISOString());
    const endWidth = ctx.measureText(endLabel).width;
    ctx.fillText(endLabel, padL + plotW - endWidth, padT + plotH + 18);
  }

  function render(data) {
    const thr = Number($("threshold").value || 70);
    const tl = data.timeline || [];
    const daylight = tl.filter(p => p.elevation > 0);

    // status
    statusEl.textContent = `Loaded. Daylight points: ${daylight.length} (of ${tl.length})`;

    // Right now decision
    const iNow = findNearestIndex(tl);
    const pNow = tl[iNow];

    if (!pNow || pNow.elevation <= 0) {
      decisionEl.textContent = "üåô Night ‚Äî no direct sun";
      decisionSubEl.textContent = "Sun is below the horizon.";
    } else if (pNow.sun_score >= thr) {
      decisionEl.textContent = "‚òÄÔ∏è Go now ‚Äî direct sun likely";
      decisionSubEl.textContent = `Sun score ${pNow.sun_score} ‚Ä¢ confidence ${Math.round((pNow.confidence||0)*100)}%`;
    } else {
      const iNext = findNextAbove(tl, iNow, thr);
      if (iNext === null) {
        decisionEl.textContent = "‚òÅÔ∏è No strong sun soon";
        decisionSubEl.textContent = `Nothing above ${thr} in the next ~6 hours (based on current model).`;
      } else {
        const mins = Math.max(0, Math.round((new Date(tl[iNext].time_utc).getTime() - Date.now()) / 60000));
        decisionEl.textContent = `üå§ Sun likely in ~${mins} min`;
        decisionSubEl.textContent = `${fmtTimeLocalFromUtcIso(tl[iNext].time_utc)} ‚Ä¢ expected score ${tl[iNext].sun_score}`;
      }
    }

    // Next window (API returns UTC)
    const win = data.next_sunny_window;
    if (!win) {
      nextEl.innerHTML = `<span class="bad">No sunny window above threshold coming up.</span>`;
    } else {
      const startLocal = fmtTimeLocalFromUtcIso(win.start_utc);
      const endLocal = fmtTimeLocalFromUtcIso(win.end_utc);
      nextEl.innerHTML = `<span class="ok">${startLocal} ‚Üí ${endLocal}</span>`;
    }

    // Sun minutes
    if (data.sun_minutes) {
      sunMinutesEl.textContent = `Expected sun: next 1h ${data.sun_minutes.next_1h} min ‚Ä¢ next 2h ${data.sun_minutes.next_2h} min`;
    } else {
      sunMinutesEl.textContent = "";
    }

    // Chart
    drawSunChart(daylight, thr, win);

    // Timeline list (daylight only)
    const rows = daylight.map(p => {
      const t = fmtTimeLocalFromUtcIso(p.time_utc);
      const score = p.sun_score;
      const conf = Math.round((p.confidence || 0) * 100);
      return `
        <div class="item">
          <div>
            <div><b>${t}</b> <span class="muted">elev ${p.elevation.toFixed(1)}¬∞</span></div>
            <div class="muted">conf ${conf}% ‚Ä¢ clouds L${p.cloud.low}% M${p.cloud.mid}% H${p.cloud.high}%</div>
          </div>
          <div>${pillForScore(score)}</div>
        </div>
      `;
    }).join("");

    timelineEl.innerHTML = rows;
  }

  async function runWithLatLon(lat, lon) {
    lastLatLon = { lat, lon };
    try {
      const data = await fetchDay(lat, lon);
      render(data);
    } catch (e) {
      statusEl.innerHTML = `<span class="bad">${e.message}</span>`;
    }
  }

  $("demoBtn").addEventListener("click", () => runWithLatLon(52.37, 4.90));

  $("locBtn").addEventListener("click", () => {
    if (!navigator.geolocation) {
      statusEl.innerHTML = `<span class="bad">Geolocation not supported in this browser.</span>`;
      return;
    }
    statusEl.textContent = "Requesting location permission‚Ä¶";
    navigator.geolocation.getCurrentPosition(
      (pos) => runWithLatLon(pos.coords.latitude, pos.coords.longitude),
      (err) => statusEl.innerHTML = `<span class="bad">Location error: ${err.message}</span>`,
      { enableHighAccuracy: true, timeout: 15000 }
    );
  });

  $("refreshBtn").addEventListener("click", () => {
    if (!lastLatLon) {
      statusEl.innerHTML = `<span class="bad">Click ‚ÄúUse my location‚Äù or ‚ÄúDemo‚Äù first.</span>`;
      return;
    }
    runWithLatLon(lastLatLon.lat, lastLatLon.lon);
  });

  // Redraw chart on resize (if we already loaded)
  window.addEventListener("resize", () => {
    if (!lastLatLon) return;
    runWithLatLon(lastLatLon.lat, lastLatLon.lon);
  });
</script>
</body>
</html>
