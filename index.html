<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iwannasun</title>
  <style>
    :root {
      --bg: #f9f9f7;
      --card: #ffffff;
      --text: #333333;
      --muted: rgba(51,51,51,0.65);
      --good: #333333;
      --warn: #f4b860;
      --bad: #ff8c72;
      --accent-blue: #9bbed9;
      --line: rgba(51,51,51,0.10);
      --sunset: linear-gradient(90deg, #f4b860, #ff8c72);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color-scheme: light;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: linear-gradient(180deg, #F9F9F7 0%, #E8DCC6 100%);
      color: var(--text);
    }
    header {
      padding: 16px 18px;
      border-bottom: 1px solid var(--line);
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: rgba(249,249,247,0.9);
      backdrop-filter: blur(10px);
      z-index: 10;
    }
    header h1 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.2px;
    }
    header .sub {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }
    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 14px;
      align-items: start; /* prevent right card stretching to match left */
    }
    .side {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    @media (max-width: 860px) {
      .grid { grid-template-columns: 1fr; }
    }
    .card {
      background: linear-gradient(180deg, #ffffff, #F9F9F7);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.08);
    }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: none; }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: rgba(155,190,217,0.18);
      color: var(--text);
      font-size: 12px;
    }

    .cityWrap { position: relative; }
    .cityInput { width: 220px; }
    @media (max-width: 520px) { .cityInput { width: 160px; } }
    .suggest {
      position: absolute;
      top: 38px;
      left: 0;
      right: 0;
      background: rgba(255,255,255,0.98);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.10);
      overflow: hidden;
      max-height: 280px;
      display: none;
      z-index: 50;
      backdrop-filter: blur(10px);
    }
    .suggest .item {
      padding: 10px 10px;
      cursor: pointer;
      border-bottom: 1px solid var(--line);
    }
    .suggest .item:last-child { border-bottom: none; }
    .suggest .item:hover { background: rgba(155,190,217,0.10); }
    .suggest .name { font-size: 13px; }
    .suggest .meta { font-size: 12px; color: var(--muted); margin-top: 2px; }
    button {
      border: 1px solid var(--line);
      background: rgba(244,184,96,0.10);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover { background: rgba(244,184,96,0.16); }
    input, select {
      border: 1px solid var(--line);
      background: rgba(249,249,247,0.9);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      outline: none;
    }
    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .kpi .box {
      padding: 10px;
      border-radius: 12px;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--line);
    }
    .kpi .label { font-size: 11px; color: var(--muted); }
    .kpi .value { font-size: 20px; margin-top: 2px; }
    .muted { color: var(--muted); }
    .big {
      font-size: 22px;
      margin: 8px 0 0;
      letter-spacing: 0.2px;
    }
    .good { color: var(--good); }
    .warn { color: var(--warn); }
    .bad { color: var(--bad); }

    .timeline {
      margin-top: 12px;
      border-top: 1px solid var(--line);
      padding-top: 10px;
      max-height: 460px;
      overflow: auto;
    }
    .trow {
      display: grid;
      grid-template-columns: 70px 1fr 60px;
      gap: 10px;
      padding: 8px 0;
      border-bottom: 1px solid var(--line);
      font-size: 13px;
    }
    .bar {
      height: 10px;
      border-radius: 999px;
      background: rgba(51,51,51,0.08);
      overflow: hidden;
      margin-top: 5px;
    }
    .bar > div {
      height: 100%;
      border-radius: 999px;
      background: var(--sunset);
      width: 0%;
    }

    canvas {
      width: 100%;
      height: 220px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(155,190,217,0.06);
      margin-top: 10px;
    }

    .footer {
      margin-top: 14px;
      color: var(--muted);
      font-size: 12px;
      text-align: center;
    }

    .err {
      margin-top: 10px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,140,114,0.35);
      background: rgba(255,140,114,0.12);
      color: var(--text);
      font-size: 13px;
      display: none;
    }

    .loadingOverlay{
      position:absolute; inset:0;
      background:rgba(249,249,247,0.75);
      backdrop-filter: blur(2px);
      display:none; align-items:center; justify-content:center;
      border-radius:14px;
    }
    .spinner{
      width:28px; height:28px; border-radius:50%;
      border:3px solid rgba(0,0,0,0.15);
      border-top-color: rgba(0,0,0,0.45);
      animation:spin 0.9s linear infinite;
    }
    @keyframes spin{ to{ transform:rotate(360deg);} }

    .small { font-size: 12px; }
    .scoreNum { color: var(--muted); font-variant-numeric: tabular-nums; }

    .chartWrap {
      display: grid;
      grid-template-columns: 34px 1fr;
      gap: 6px;
      align-items: stretch;
      margin-top: 8px;
    }
    .yAxis {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 8px 0 10px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
    .xAxis {
      display: flex;
      justify-content: space-between;
      padding-left: 40px; /* yAxis width + gap */
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>iwannasun</h1>
      <div class="sub">Will I get direct sunlight here?</div>
    </div>
    <div class="row">
      <div class="cityWrap">
        <input id="cityInput" class="cityInput" type="text" inputmode="search" autocomplete="off" placeholder="Search city…" />
        <div id="cityResults" class="suggest"></div>
      </div>
      <span class="pill" id="locPill">—</span>
      <button id="btnHere">Use my location</button>
      <button id="btnDemo">Demo</button>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <div class="card" style="position:relative;">
        <div id="loadingOverlay" class="loadingOverlay"><div class="spinner"></div></div>
        <div class="row" style="justify-content: space-between;">
          <div>
            <div class="muted small">Decision</div>
            <div class="big" id="decisionWrap"><span id="decisionText">—</span> <span class="muted small" id="whyInline"></span></div>
          </div>
          <div class="row">
            <select id="daySelect">
              <option value="0">Today</option>
              <option value="1">Tomorrow</option>
            </select>
            <button id="btnRefresh">Refresh</button>
          </div>
        </div>

        <div class="kpi">
          <div class="box">
            <div class="label">Sun score now</div>
            <div class="value" id="scoreNow">—</div>
          </div>
          <div class="box">
            <div class="label">Confidence now <span class="muted" title="How reliable the sun score estimate is (higher = more stable conditions).">ⓘ</span></div>
            <div class="value" id="confNow">—</div>
          </div>
          <div class="box">
            <div class="label">Sunny minutes next 1h</div>
            <div class="value" id="sun60">—</div>
          </div>
          <div class="box">
            <div class="label">Sunny minutes next 2h</div>
            <div class="value" id="sun120">—</div>
          </div>
        </div>

        <div class="chartBlock" style="margin-top:10px">
          <div class="small" id="chartTitle" style="opacity:0.85; display:flex; justify-content:space-between;"><span>Elevation (°)</span><span>line intensity = sun score</span></div>
          <div class="chartWrap">
            <div class="yAxis" id="yAxis"></div>
            <canvas id="sunChart" width="900" height="250"></canvas>
          </div>
          <div class="xAxis" id="xAxis"></div>
        </div>

        <div class="timeline" id="timeline"></div>
        <div class="err" id="errBox"></div>
      </div>

      <div class="side">
        <div class="card">
          <div class="muted small">Next sunny window</div>
          <div class="big" id="nextWindow">—</div>
          <div class="muted" id="nextWindowSub" style="margin-top:6px">—</div>

          <div style="margin-top: 12px; display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap;">
            <div>
              <div class="muted small">Sunrise</div>
              <div class="big" id="sunriseTime" style="font-size:18px; margin-top:4px;">—</div>
            </div>
            <div>
              <div class="muted small">Sunset</div>
              <div class="big" id="sunsetTime" style="font-size:18px; margin-top:4px;">—</div>
            </div>
          </div>
        </div>

        <div class="card notes">
          <div class="muted small">About</div>
          <div class="muted small" style="line-height:1.45; margin-top:6px">
            Sun Score = probability of direct sun reaching you (0–100). Not a weather forecast. Low sun = distant clouds matter more.
            <br><br>
            Confidence is reliability (drops when conditions are mixed or rainy).
          </div>
        </div>
      </div>
    </div>

    <div class="footer"></div>
  </div>

<script>
  const API_BASE = "https://iwannasun.onrender.com";
  const DEFAULT_THRESHOLD = 70; // product tuning constant (UI removed)

  const locPill = document.getElementById('locPill');
  const cityInput = document.getElementById('cityInput');
  const cityResults = document.getElementById('cityResults');
  const errBox = document.getElementById('errBox');
  const loadingOverlay = document.getElementById('loadingOverlay');

  const decisionWrap = document.getElementById('decisionWrap');
  const decisionText = document.getElementById('decisionText');
  const scoreNow = document.getElementById('scoreNow');
  const confNow = document.getElementById('confNow');
  const sun60 = document.getElementById('sun60');
  const sun120 = document.getElementById('sun120');

  const daySelect = document.getElementById('daySelect');

  const nextWindow = document.getElementById('nextWindow');
  const nextWindowSub = document.getElementById('nextWindowSub');
  const sunriseEl = document.getElementById('sunriseTime');
  const sunsetEl = document.getElementById('sunsetTime');

  const timelineEl = document.getElementById('timeline');
  const yAxisEl = document.getElementById('yAxis');
  const xAxisEl = document.getElementById('xAxis');
  const canvas = document.getElementById('sunChart');
  const ctx = canvas.getContext('2d');

  let state = {
    lat: null,
    lon: null,
    data: null,
  };

  function setLocation(lat, lon, label = null) {
    state.lat = lat;
    state.lon = lon;

    // Location pill: show a human label when we have one, otherwise coordinates.
    if (label && String(label).trim().length) {
      locPill.textContent = label;
    } else {
      locPill.textContent = `${Number(lat).toFixed(4)}, ${Number(lon).toFixed(4)}`;
    }

    // City input reflects manual city picks; for "Use my location" we clear it.
    if (cityInput) {
      if (label && label !== 'My location') cityInput.value = label;
      else cityInput.value = '';
    }
  }

  // --- City search (typeahead) via Open‑Meteo Geocoding ---
  let _cityTimer = null;
  let _lastCityQuery = '';
  let _lastCityResults = [];

  function hideCityResults() {
    if (!cityResults) return;
    cityResults.style.display = 'none';
    cityResults.innerHTML = '';
  }

  function renderCityResults(list) {
    if (!cityResults) return;
    if (!list || !list.length) {
      hideCityResults();
      return;
    }
    cityResults.innerHTML = list.map((r, idx) => {
      const name = r.name || '—';
      const admin = r.admin1 ? `, ${r.admin1}` : '';
      const country = r.country ? `, ${r.country}` : '';
      let meta = `${admin}${country}`;
      if (meta.startsWith(', ')) meta = meta.slice(2);
      return `<div class="item" data-idx="${idx}">
        <div class="name">${name}</div>
        <div class="meta">${meta}</div>
      </div>`;
    }).join('');
    cityResults.style.display = 'block';
  }

  async function searchCities(q) {
    const query = (q || '').trim();
    if (query.length < 2) {
      hideCityResults();
      return;
    }
    if (query === _lastCityQuery) return;
    _lastCityQuery = query;

    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=6&language=en&format=json`;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error('geocoding failed');
      const data = await res.json();
      const results = (data && data.results) ? data.results : [];
      _lastCityResults = results;
      renderCityResults(results);
    } catch (e) {
      hideCityResults();
      console.warn(e);
    }
  }

  if (cityInput) {
    cityInput.addEventListener('input', (e) => {
      const v = e.target.value;
      clearTimeout(_cityTimer);
      _cityTimer = setTimeout(() => searchCities(v), 220);
    });

    cityInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') hideCityResults();
      if (e.key === 'Enter') {
        if (_lastCityResults && _lastCityResults.length) {
          const r = _lastCityResults[0];
          const label = `${r.name}${r.country ? ', ' + r.country : ''}`;
          setLocation(Number(r.latitude), Number(r.longitude), label);
          cityInput.value = label;
          hideCityResults();
          fetchDay(true);
        }
      }
    });
  }

  if (cityResults) {
    cityResults.addEventListener('mousedown', (e) => {
      const item = e.target.closest('.item');
      if (!item) return;
      const idx = Number(item.getAttribute('data-idx'));
      const r = _lastCityResults[idx];
      if (!r) return;
      const label = `${r.name}${r.country ? ', ' + r.country : ''}`;
      setLocation(Number(r.latitude), Number(r.longitude), label);
      if (cityInput) cityInput.value = label;
      hideCityResults();
      fetchDay(true);
    });
  }

  document.addEventListener('click', (e) => {
    if (!cityResults || !cityInput) return;
    if (e.target === cityInput || cityResults.contains(e.target)) return;
    hideCityResults();
  });

  function showError(msg) {
    errBox.style.display = 'block';
    errBox.textContent = msg;
  }
  function clearError() {
    errBox.style.display = 'none';
    errBox.textContent = '';
  }

  function fmtTime(iso) {
    const d = new Date(iso);
    return d.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
  }

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function windowMinutes(startIso, endIso) {
    const a = new Date(startIso);
    const b = new Date(endIso);
    return Math.max(0, Math.round((b - a) / 60000));
  }

  function renderDecision(nowRow) {
    const whyEl = document.getElementById('whyInline');

    if (!nowRow) {
      decisionText.textContent = '—';
      if (decisionWrap) decisionWrap.className = 'big';
      scoreNow.textContent = '—';
      confNow.textContent = '—';
      if (whyEl) whyEl.textContent = '';
      return;
    }

    const s = Number(nowRow.sun_score || 0);
    const c = Number(nowRow.confidence || 0);

    scoreNow.textContent = Math.round(s);
    scoreNow.className = 'value';

    confNow.textContent = Math.round(c * 100) + '%';
    confNow.title = 'Confidence = how reliable the sun score estimate is (higher = more stable conditions).';

    if (s >= DEFAULT_THRESHOLD) {
      decisionText.textContent = 'Go now';
      if (decisionWrap) decisionWrap.className = 'big good';
    } else if (s >= DEFAULT_THRESHOLD - 15) {
      decisionText.textContent = 'Maybe soon';
      if (decisionWrap) decisionWrap.className = 'big warn';
    } else {
      decisionText.textContent = 'Wait';
      if (decisionWrap) decisionWrap.className = 'big bad';
    }

    // WHY (short, decision-oriented)
    if (whyEl) {
      if (Number(nowRow.elevation || 0) <= 0) {
        whyEl.textContent = '— because sun is below the horizon.';
      } else {
        const low = nowRow.cloud?.low ?? null;
        const mid = nowRow.cloud?.mid ?? null;
        const high = nowRow.cloud?.high ?? null;
        const precip = nowRow.cloud?.precip_mm ?? 0;

        let main = null;
        const parts = [];
        if (precip && precip > 0) parts.push('precipitation');

        const layers = [
          { name: 'low clouds', v: low },
          { name: 'mid clouds', v: mid },
          { name: 'high clouds', v: high },
        ].filter(x => typeof x.v === 'number');

        if (layers.length) {
          layers.sort((a,b) => b.v - a.v);
          main = `${layers[0].name} (${Math.round(layers[0].v)}%)`;
        }
        if (main) parts.push(main);

        if (!parts.length) {
          whyEl.textContent = '— clear sky and sun above horizon.';
        } else {
          const prefix = (s >= DEFAULT_THRESHOLD) ? '— clear despite ' : '— blocked by ';
          whyEl.textContent = prefix + parts.join(' + ') + '.';
        }
      }
    }
  }

  function renderNextWindow(win) {
    if (!win) {
      nextWindow.textContent = 'No sunny window';
      nextWindow.className = 'big bad';
      nextWindowSub.textContent = 'Try again later.';
      return;
    }

    const a = fmtTime(win.start);
    const b = fmtTime(win.end);

    nextWindow.textContent = `${a} – ${b}`;
    nextWindow.className = 'big good';

    const mins = (win.minutes != null) ? win.minutes : windowMinutes(win.start, win.end);
    nextWindowSub.textContent = `${mins} minutes above threshold`;
  }

  function daylightWindow(dayRows, padMinutes = 30) {
    // Returns {start: Date, end: Date} where start is padMinutes before first sun-up,
    // and end is padMinutes after last sun-up. If no daylight, returns null.
    const rows = (dayRows || []);
    let first = null;
    let last = null;
    for (const r of rows) {
      if (Number(r.elevation || 0) > 0) { first = new Date(r.time_local); break; }
    }
    for (let i = rows.length - 1; i >= 0; i--) {
      if (Number(rows[i].elevation || 0) > 0) { last = new Date(rows[i].time_local); break; }
    }
    if (!first || !last) return null;
    const start = new Date(first.getTime() - padMinutes * 60000);
    const end = new Date(last.getTime() + padMinutes * 60000);
    return { start, end };
  }

  function renderTimeline(dayRows) {
    timelineEl.innerHTML = '';

    const head = document.createElement('div');
    head.className = 'trow muted small';
    head.innerHTML = '<div>Time</div><div>Sun score</div><div>Confidence</div>';
    timelineEl.appendChild(head);

    const win = daylightWindow(dayRows, 30);
    const rows = (dayRows || []).filter(r => {
      const t = new Date(r.time_local);
      return win ? (t >= win.start && t <= win.end) : (Number(r.elevation || 0) > 0);
    });

    for (const r of rows) {
      const t = fmtTime(r.time_local);
      const s = Math.round(Number(r.sun_score || 0));

      const el = document.createElement('div');
      el.className = 'trow';

      const left = document.createElement('div');
      left.textContent = t;
      left.className = 'muted';

      const mid = document.createElement('div');
      const label = document.createElement('div');
      label.textContent = s + '%';
      label.className = 'scoreNum';

      const bar = document.createElement('div');
      bar.className = 'bar';
      const fill = document.createElement('div');
      fill.style.width = clamp(s, 0, 100) + '%';
      bar.appendChild(fill);

      mid.appendChild(label);
      mid.appendChild(bar);

      const right = document.createElement('div');
      right.textContent = Math.round(Number(r.confidence || 0) * 100) + '%';
      right.title = 'Confidence in prediction';
      right.className = 'muted';

      el.appendChild(left);
      el.appendChild(mid);
      el.appendChild(right);

      timelineEl.appendChild(el);
    }
  }

  function renderChart(dayRows) {
    // Make canvas crisp on high-DPI screens
    const cssW = canvas.clientWidth || 900;
    const cssH = 250; // keep in sync with <canvas height>
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const w = cssW;
    const h = cssH;

    ctx.clearRect(0, 0, w, h);

    if (!dayRows || !dayRows.length) {
      if (yAxisEl) yAxisEl.innerHTML = '';
      if (xAxisEl) xAxisEl.innerHTML = '';
      return;
    }

    // Trim to (sunrise - 30m) .. (sunset + 30m)
    const win = daylightWindow(dayRows, 30);
    if (!win) {
      if (yAxisEl) yAxisEl.innerHTML = '';
      if (xAxisEl) xAxisEl.innerHTML = '';
      return;
    }

    // Find indices within padded window
    let startIdx = 0;
    let endIdx = dayRows.length - 1;
    for (let i = 0; i < dayRows.length; i++) {
      if (new Date(dayRows[i].time_local) >= win.start) { startIdx = Math.max(0, i); break; }
    }
    for (let i = dayRows.length - 1; i >= 0; i--) {
      if (new Date(dayRows[i].time_local) <= win.end) { endIdx = Math.min(dayRows.length - 1, i); break; }
    }

    const rows = dayRows.slice(startIdx, endIdx + 1);

    const elevs = rows.map(r => Math.max(0, Number(r.elevation || 0)));
    const maxElevRaw = Math.max(...elevs, 1);
    const maxElev = Math.max(10, Math.ceil(maxElevRaw / 10) * 10); // nice round top

    // Axes labels outside canvas
    if (yAxisEl) {
      const ticks = [];
      for (let d = maxElev; d >= 0; d -= 10) ticks.push(d);
      yAxisEl.innerHTML = ticks.map(d => `<div>${d}°</div>`).join('');
    }

    if (xAxisEl) {
      const t0 = new Date(rows[0].time_local);
      const t1 = new Date(rows[rows.length - 1].time_local);
      const steps = 4;
      const labels = [];
      for (let k = 0; k <= steps; k++) {
        const tt = new Date(t0.getTime() + (k / steps) * (t1 - t0));
        const hh = tt.getHours().toString().padStart(2, '0');
        labels.push(`${hh}:00`);
      }
      xAxisEl.innerHTML = labels.map(t => `<div>${t}</div>`).join('');
    }

    const padX = 14;
    const padTop = 14;
    const padBottom = 18;

    function yOf(e) {
      const usableH = h - padTop - padBottom;
      const yy = (h - padBottom) - (e / maxElev) * usableH;
      return clamp(yy, padTop, h - padBottom);
    }

    function xOf(i) {
      if (rows.length === 1) return w / 2;
      return padX + (i / (rows.length - 1)) * (w - 2 * padX);
    }

    // --- subtle gridlines (cleaner, more "chart-like") ---
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 4]);
    ctx.strokeStyle = 'rgba(0,0,0,0.10)';
    for (let d = 0; d <= maxElev; d += 10) {
      const y = yOf(d);
      ctx.beginPath();
      ctx.moveTo(padX, y);
      ctx.lineTo(w - padX, y);
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // --- build elevation path ---
    const pts = rows.map((r, i) => {
      const e = Math.max(0, Number(r.elevation || 0));
      return { x: xOf(i), y: yOf(e), e, s: Number(r.sun_score || 0), t: new Date(r.time_local) };
    });

    // --- soft fill under curve (professional look) ---
    // Fill alpha follows average sun score across the day.
    const avgScore = pts.reduce((acc, p) => acc + p.s, 0) / Math.max(1, pts.length);
    const fillAlpha = 0.05 + 0.12 * clamp(avgScore / 100, 0, 1);
    const fillGrad = ctx.createLinearGradient(0, padTop, 0, h);
    fillGrad.addColorStop(0, `rgba(244,184,96,${fillAlpha})`);
    fillGrad.addColorStop(1, `rgba(255,140,114,0)`);

    ctx.beginPath();
    ctx.moveTo(pts[0].x, h - padBottom);
    for (const p of pts) ctx.lineTo(p.x, p.y);
    ctx.lineTo(pts[pts.length - 1].x, h - padBottom);
    ctx.closePath();
    ctx.fillStyle = fillGrad;
    ctx.fill();

    // --- base elevation line (thin, neutral) ---
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.beginPath();
    for (let i = 0; i < pts.length; i++) {
      if (i === 0) ctx.moveTo(pts[i].x, pts[i].y);
      else ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.strokeStyle = 'rgba(0,0,0,0.26)';
    ctx.stroke();

    // --- sun score overlay: opacity + thickness vary with score + subtle glow ---
    const grad = ctx.createLinearGradient(0, 0, w, 0);
    grad.addColorStop(0, '#ff8c72');
    grad.addColorStop(0.5, '#f4b860');
    grad.addColorStop(1, '#ff8c72');

    for (let i = 1; i < pts.length; i++) {
      const a = pts[i - 1], b = pts[i];
      // avoid weird tails below horizon
      if (a.e <= 0 || b.e <= 0) continue;

      const t = clamp(((a.s + b.s) / 2) / 100, 0, 1);
      const elev = (a.e + b.e) / 2;

      // IMPORTANT: don't fade the main line with elevation (that hides "clear sunset" vs "cloud fade").
      // Instead: keep alpha driven by sun_score, and only reduce thickness/glow near the horizon.
      const alpha = 0.10 + 0.90 * t;

      // Slightly thinner near horizon to prevent the end "blob", but still readable.
      const thinNearHorizon = 0.55 + 0.45 * clamp(elev / 6, 0, 1);
      const lw = (2.5 + 7.0 * (t ** 0.9)) * thinNearHorizon;

      // Glow fades near horizon (this is what caused the weird red-circle artifact)
      const glowFade = clamp(elev / 8, 0, 1);

      const grad = ctx.createLinearGradient(0, 0, w, 0);
      grad.addColorStop(0, '#ff8c72');
      grad.addColorStop(0.5, '#f4b860');
      grad.addColorStop(1, '#ff8c72');

      // Glow pass (very subtle)
      ctx.save();
      ctx.globalAlpha = alpha * 0.35 * glowFade;
      ctx.lineWidth = lw + 5;
      ctx.strokeStyle = grad;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();

      // Main pass
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.lineWidth = lw;
      ctx.strokeStyle = grad;
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
      ctx.restore();
    }

    // --- markers: now ---

    // Now marker (if within chart range)
    const now = Date.now();
    const t0ms = pts[0].t.getTime();
    const t1ms = pts[pts.length - 1].t.getTime();
    if (now >= t0ms && now <= t1ms) {
      const u = clamp((now - t0ms) / Math.max(1, (t1ms - t0ms)), 0, 1);
      const xn = padX + u * (w - 2 * padX);
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 4]);
      ctx.beginPath();
      ctx.moveTo(xn, padTop);
      ctx.lineTo(xn, h - padBottom);
      ctx.stroke();
      ctx.setLineDash([]);

      // small dot at curve height (nearest point)
      const idx = Math.round(u * (pts.length - 1));
      const p = pts[clamp(idx, 0, pts.length - 1)];
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.beginPath();
      ctx.arc(xn, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    
  }

  function nearestNowRow(dayRows) {
    const now = new Date();
    let best = null;
    let bestDt = Infinity;
    for (const r of (dayRows || [])) {
      const t = new Date(r.time_local);
      const dt = Math.abs(t - now);
      if (dt < bestDt) { bestDt = dt; best = r; }
    }
    return best;
  }

  function cacheKey(lat, lon, threshold) {
    const rlat = Number(lat).toFixed(4);
    const rlon = Number(lon).toFixed(4);
    const thr = Number(threshold);
    return `iwannasun_day_${rlat}_${rlon}_${thr}`;
  }

  function loadCached(lat, lon, threshold, maxAgeMs = 5 * 60 * 1000) {
    try {
      const key = cacheKey(lat, lon, threshold);
      const raw = sessionStorage.getItem(key);
      if (!raw) return null;
      const obj = JSON.parse(raw);
      if (!obj || !obj.ts || !obj.data) return null;
      if (Date.now() - obj.ts > maxAgeMs) return null;
      return obj.data;
    } catch {
      return null;
    }
  }

  function saveCached(lat, lon, threshold, data) {
    try {
      const key = cacheKey(lat, lon, threshold);
      sessionStorage.setItem(key, JSON.stringify({ ts: Date.now(), data }));
    } catch {
      // ignore quota / privacy mode
    }
  }

  async function fetchDay(force = false) {
    if (loadingOverlay) loadingOverlay.style.display = 'flex';
    clearError();

    const lat = state.lat;
    const lon = state.lon;
    if (lat == null || lon == null) {
      showError('No location set');
      return;
    }

    const threshold = DEFAULT_THRESHOLD;

    // loc pill is set via setLocation()

    const url = `${API_BASE}/day?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&threshold=${encodeURIComponent(threshold)}&days=2&model=ray`;

    if (!force) {
      const cached = loadCached(lat, lon, threshold);
      if (cached) {
        state.data = cached;
        render();
        return;
      }
    }

    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`API error ${res.status}`);
      const data = await res.json();
      state.data = data;
      saveCached(lat, lon, threshold, data);
      render();
      if (loadingOverlay) loadingOverlay.style.display = 'none';
    } catch (e) {
      showError('Failed to fetch. Try again.');
      console.error(e);
      if (loadingOverlay) loadingOverlay.style.display = 'none';
    }
  }

  function render() {
    if (!state.data) return;

    const dayIndex = Number(daySelect?.value || 0);
    const rows = state.data.timeline.filter(r => Number(r.day_index) === dayIndex);

    const nowRow = nearestNowRow(rows);
    renderDecision(nowRow);

    const win = state.data.next_sunny_window_by_day
      ? (state.data.next_sunny_window_by_day[String(dayIndex)] || null)
      : (state.data.next_sunny_window || null);
    renderNextWindow(win);

    // Sunrise / Sunset for selected day (based on elevation crossing)
    const dayWin = daylightWindow(rows, 0);
    if (sunriseEl && sunsetEl) {
      if (!dayWin) {
        sunriseEl.textContent = '—';
        sunsetEl.textContent = '—';
        sunriseEl.title = 'No sunrise (sun stays below horizon)';
        sunsetEl.title = 'No sunset (sun stays below horizon)';
      } else {
        sunriseEl.textContent = fmtTime(dayWin.start.toISOString());
        sunsetEl.textContent = fmtTime(dayWin.end.toISOString());
        sunriseEl.title = dayWin.start.toLocaleString();
        sunsetEl.title = dayWin.end.toLocaleString();
      }
    }

    if (state.data.sun_minutes) {
      sun60.textContent = state.data.sun_minutes.next_1h ?? '—';
      sun120.textContent = state.data.sun_minutes.next_2h ?? '—';
    }

    renderChart(rows);
    renderTimeline(rows);
  }

  function useDemo() {
    setLocation(52.3676, 4.9041, 'Amsterdam');
    fetchDay();
  }

  function useHere() {
    if (!navigator.geolocation) {
      showError('Geolocation not supported');
      return;
    }
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        setLocation(pos.coords.latitude, pos.coords.longitude, null);
        fetchDay();
      },
      () => showError('Location permission denied'),
      { enableHighAccuracy: true, timeout: 10000 }
    );
  }

  document.getElementById('btnDemo').addEventListener('click', useDemo);
  document.getElementById('btnHere').addEventListener('click', useHere);
  document.getElementById('btnRefresh').addEventListener('click', () => fetchDay(true));
  daySelect.addEventListener('change', () => { if (state.data) render(); });

  // load demo on start
  useDemo();
</script>
</body>
</html>
