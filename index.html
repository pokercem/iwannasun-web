<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iwannasun</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; line-height: 1.35; }
    h1 { margin: 0 0 8px 0; }
    .muted { color: #666; font-size: 14px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 12px 0; }
    button, input { font-size: 16px; padding: 10px 12px; }
    button { cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 13px; }
    .ok { color: #0a7; }
    .bad { color: #c22; }
    .timeline { max-height: 55vh; overflow: auto; }
    .item { display: flex; justify-content: space-between; gap: 10px; padding: 8px 0; border-bottom: 1px solid #f0f0f0; }
    .pill { padding: 2px 8px; border-radius: 999px; border: 1px solid #ddd; font-size: 13px; }
  </style>
</head>
<body>
  <h1>iwannasun</h1>
  <div class="muted">Direct sun probability ‚Äî simple MVP</div>

  <div class="card">
    <div class="row">
      <button id="locBtn">Use my location</button>
      <button id="demoBtn">Demo (Amsterdam)</button>
    </div>

    <div class="row">
      <label class="muted">Sunny threshold (0‚Äì100)</label>
      <input id="threshold" type="number" min="0" max="100" value="70" style="width: 110px;">
    </div>

    <div class="muted">API:</div>
    <div class="mono" id="apiUrl">https://iwannasun.onrender.com</div>
    <div class="muted">(If your API URL changes, edit it in this file.)</div>
  </div>

  <div class="card">
    <div id="status" class="muted">Waiting‚Ä¶</div>
  </div>
  
  <div class="card">
    <h3 style="margin:0 0 8px 0;">Right now</h3>
    <div id="decision" style="font-size:18px;">‚Äî</div>
    <div id="decisionSub" class="muted"></div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px 0;">Next sunny window</h3>
    <div id="nextWindow" class="muted">‚Äî</div>
  </div>
  
  <div class="card">
    <div style="display:flex; align-items:baseline; justify-content:space-between; gap:12px;">
      <h3 style="margin:0;">Sun path today</h3>
      <div class="muted" style="font-size:12px;">
        Highlight when sun_score ‚â• <span id="thrLabel">70</span>
      </div>
    </div>

    <canvas id="sunChart" style="width:100%; height:260px; display:block; margin-top:10px; border:1px solid #eee; border-radius:10px;"></canvas>

    <div class="muted" style="font-size:12px; margin-top:8px;">
      Gray = blocked/weak direct sun ‚Ä¢ Orange = likely direct sun ‚Ä¢ Line = sun elevation
    </div>
  </div>

  <div class="card timeline">
    <h3 style="margin:0 0 8px 0;">Today (daylight only, 10-min steps)</h3>
    <div id="timeline"></div>
  </div>

<script>
  const API_BASE = "https://iwannasun.onrender.com";

  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const nextEl = $("nextWindow");
  const timelineEl = $("timeline");
  const decisionEl = $("decision");
  const decisionSubEl = $("decisionSub");
  // ===== Canvas Sun Path Chart (no libraries) =====
  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function parseMs(iso) {
    const ms = new Date(iso).getTime();
    return Number.isFinite(ms) ? ms : NaN;
  }

  function fmtHM(dateObj) {
    const hh = String(dateObj.getHours()).padStart(2, "0");
    const mm = String(dateObj.getMinutes()).padStart(2, "0");
    return `${hh}:${mm}`;
  }

  function getDPR() {
    return window.devicePixelRatio || 1;
  }

  function setupCanvas(canvas) {
    const ctx = canvas.getContext("2d");
    const dpr = getDPR();

    // Use CSS size; set internal pixel size for crisp lines
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    // Draw in CSS pixels
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, cssW, cssH);

    return { ctx, w: cssW, h: cssH };
  }

  function drawSunChart(data) {
    const canvas = $("sunChart");
    if (!canvas) return;

    const thr = Number($("threshold").value || 70);
    const thrLabel = $("thrLabel");
    if (thrLabel) thrLabel.textContent = String(thr);

    const tl = data.timeline || [];
    if (!Array.isArray(tl) || tl.length < 2) return;

    // Build points sorted by time
    const pts = tl.map(p => ({
      ms: parseMs(p.time_utc),
      elev: Number(p.elevation),
      score: Number(p.sun_score)
    }))
    .filter(p => Number.isFinite(p.ms) && Number.isFinite(p.elev) && Number.isFinite(p.score))
    .sort((a, b) => a.ms - b.ms);

    if (pts.length < 2) return;

    const tMin = pts[0].ms;
    const tMax = pts[pts.length - 1].ms;

    // Elevation range (0..max)
    const eMax = Math.max(5, Math.ceil(Math.max(...pts.map(p => p.elev))));
    const eMin = 0;

    const { ctx, w, h } = setupCanvas(canvas);

    const pad = { left: 46, right: 14, top: 16, bottom: 28 };
    const left = pad.left, right = w - pad.right;
    const top = pad.top, bottom = h - pad.bottom;

    // Background
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, w, h);

    // Plot border
    ctx.strokeStyle = "#ddd";
    ctx.lineWidth = 1;
    ctx.strokeRect(left, top, right - left, bottom - top);

    // Horizontal grid + elevation labels
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillStyle = "#444";
    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 1;

    const gridLines = 4;
    for (let i = 0; i <= gridLines; i++) {
      const u = i / gridLines;                // 0..1
      const y = top + (bottom - top) * (1 - u);
      ctx.beginPath();
      ctx.moveTo(left, y);
      ctx.lineTo(right, y);
      ctx.stroke();

      const elevVal = Math.round(eMin + (eMax - eMin) * u);
      ctx.fillText(`${elevVal}¬∞`, 6, y + 4);
    }

    // Time labels (start / mid / end)
    const startD = new Date(tMin);
    const midD = new Date((tMin + tMax) / 2);
    const endD = new Date(tMax);

    ctx.fillStyle = "#444";
    ctx.fillText(fmtHM(startD), left, h - 8);
    ctx.fillText(fmtHM(midD), (left + right) / 2 - 16, h - 8);
    ctx.fillText(fmtHM(endD), right - 40, h - 8);

    function xFromMs(ms) {
      const u = (ms - tMin) / (tMax - tMin);
      return left + u * (right - left);
    }

    function yFromElev(elev) {
      const v = (elev - eMin) / (eMax - eMin);
      return bottom - v * (bottom - top);
    }

    // Shade next sunny window
    const win = data.next_sunny_window;
    if (win && win.start && win.end) {
      const s = parseMs(win.start);
      const e = parseMs(win.end);
      if (Number.isFinite(s) && Number.isFinite(e)) {
        const sC = clamp(s, tMin, tMax);
        const eC = clamp(e, tMin, tMax);
        if (eC > sC) {
          const x1 = xFromMs(sC);
          const x2 = xFromMs(eC);

          ctx.fillStyle = "rgba(246, 183, 60, 0.12)";
          ctx.fillRect(x1, top, x2 - x1, bottom - top);

          ctx.strokeStyle = "rgba(246, 183, 60, 0.45)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x1, top); ctx.lineTo(x1, bottom);
          ctx.moveTo(x2, top); ctx.lineTo(x2, bottom);
          ctx.stroke();
        }
      }
    }

    // Draw elevation curve segments, colored by sun_score
    const sunnyColor = "#f6b73c";
    const grayColor = "rgba(120,120,120,0.55)";

    ctx.lineWidth = 2;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    for (let i = 0; i < pts.length - 1; i++) {
      const a = pts[i];
      const b = pts[i + 1];

      const aElev = Math.max(0, a.elev);
      const bElev = Math.max(0, b.elev);

      const x1 = xFromMs(a.ms);
      const y1 = yFromElev(aElev);
      const x2 = xFromMs(b.ms);
      const y2 = yFromElev(bElev);

      const isSunny = (a.score >= thr) && (aElev > 0.1);
      ctx.strokeStyle = isSunny ? sunnyColor : grayColor;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // Draw "now" vertical marker
    const now = Date.now();
    if (now >= tMin && now <= tMax) {
      const x = xFromMs(now);
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, top);
      ctx.lineTo(x, bottom);
      ctx.stroke();

      ctx.fillSty

  function findNearestIndex(timeline) {
    const now = Date.now();
    let bestI = 0;
    let bestD = Infinity;
    for (let i = 0; i < timeline.length; i++) {
      const t = new Date(timeline[i].time_utc).getTime();
      const d = Math.abs(t - now);
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI;
  }

  function findNextAbove(timeline, startIndex, threshold, maxMinutesAhead = 360) {
  const now = Date.now();
  const maxMs = maxMinutesAhead * 60 * 1000;
  for (let i = startIndex; i < timeline.length; i++) {
    const tMs = new Date(timeline[i].time_utc).getTime();
    if (tMs - now > maxMs) break;
    if (timeline[i].sun_score >= threshold && timeline[i].elevation > 0) return i;
  }
  return null;
}

  function fmtTimeLocal(isoUtc) {
    // Convert ISO UTC string to user‚Äôs browser local time
    const d = new Date(isoUtc);
    return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  }

  function scoreLabel(score) {
    if (score >= 80) return "SUN";
    if (score >= 60) return "MIX";
    if (score >= 30) return "CLOUD";
    return "NO";
  }

  function pillForScore(score) {
    const label = scoreLabel(score);
    return `<span class="pill">${label} ${score}</span>`;
  }

  async function fetchDay(lat, lon) {
    const thr = Number($("threshold").value || 70);
    const url = `${API_BASE}/day?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&threshold=${encodeURIComponent(thr)}`;
    $("apiUrl").textContent = API_BASE;
    statusEl.textContent = "Loading‚Ä¶ (free server may take a bit to wake up)";
    const res = await fetch(url);
    if (!res.ok) throw new Error(`API error: ${res.status}`);
    return await res.json();
  }

  function render(data) {
    const win = data.next_sunny_window;

        // Decision banner
    const thr = Number($("threshold").value || 70);
    const tl = data.timeline;

    const iNow = findNearestIndex(tl);
    const pNow = tl[iNow];

    if (pNow.elevation <= 0) {
      decisionEl.textContent = "üåô Night ‚Äî no direct sun";
      decisionSubEl.textContent = "Sun is below the horizon.";
    } else if (pNow.sun_score >= thr) {
      decisionEl.textContent = "‚òÄÔ∏è Go now ‚Äî direct sun likely";
      decisionSubEl.textContent = `Sun score ${pNow.sun_score} ‚Ä¢ confidence ${Math.round((pNow.confidence||0)*100)}%`;
    } else {
      const iNext = findNextAbove(tl, iNow, thr);
      if (iNext === null) {
        decisionEl.textContent = "‚òÅÔ∏è No strong sun soon";
        decisionSubEl.textContent = `Nothing above ${thr} in the next ~6 hours (based on current model).`;
      } else {
        const mins = Math.max(0, Math.round((new Date(tl[iNext].time_utc).getTime() - Date.now()) / 60000));
        decisionEl.textContent = `üå§ Sun likely in ~${mins} min`;
        decisionSubEl.textContent = `${fmtTimeLocal(tl[iNext].time_utc)} ‚Ä¢ expected score ${tl[iNext].sun_score}`;
      }
    }

    const now = Date.now();

if (!win || new Date(win.end).getTime() < now) {
  nextEl.innerHTML = `<span class="bad">No more sun today</span>`;
} else {
  const start = new Date(win.start);
  const end = new Date(win.end);

  if (start.getTime() < now) {
    nextEl.innerHTML =
      `<span class="ok">Happening now ‚Üí ${end.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}</span>`;
  } else {
    nextEl.innerHTML =
      `<span class="ok">${start.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})} ‚Üí ${end.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}</span>`;
  }
}


    const rows = data.timeline
      .filter(p => p.elevation > 0)
      .map(p => {

      const t = fmtTimeLocal(p.time_utc);
      const score = p.sun_score;
      const conf = Math.round((p.confidence || 0) * 100);
      return `
        <div class="item">
          <div>
            <div><b>${t}</b> <span class="muted">elev ${p.elevation.toFixed(1)}¬∞</span></div>
            <div class="muted">conf ${conf}% ‚Ä¢ clouds L${p.cloud.low}% M${p.cloud.mid}% H${p.cloud.high}%</div>
          </div>
          <div>${pillForScore(score)}</div>
        </div>
      `;
    }).join("");

    timelineEl.innerHTML = rows;
    
    __lastDayDataForChart = data;
    drawSunChart(data);    
    
    statusEl.textContent = `Loaded. Daylight points: ${data.timeline.filter(p => p.elevation > 0).length}`;
  }

  async function runWithLatLon(lat, lon) {
    try {
      const data = await fetchDay(lat, lon);
      render(data);
    } catch (e) {
      statusEl.innerHTML = `<span class="bad">${e.message}</span>`;
    }
  }

  $("demoBtn").addEventListener("click", () => runWithLatLon(52.37, 4.90));

  $("locBtn").addEventListener("click", () => {
    if (!navigator.geolocation) {
      statusEl.innerHTML = `<span class="bad">Geolocation not supported in this browser.</span>`;
      return;
    }
    statusEl.textContent = "Requesting location permission‚Ä¶";
    navigator.geolocation.getCurrentPosition(
      (pos) => runWithLatLon(pos.coords.latitude, pos.coords.longitude),
      (err) => statusEl.innerHTML = `<span class="bad">Location error: ${err.message}</span>`,
      { enableHighAccuracy: true, timeout: 15000 }
    );
  });
</script>
</body>
</html>
